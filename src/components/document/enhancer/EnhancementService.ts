
/**
 * Document enhancement service providing AI-powered content improvements
 */

// API key for testing
let openaiApiKey: string | null = null;

// Helper to set the API key and store it in localStorage
export const setOpenAIApiKey = (apiKey: string): void => {
  openaiApiKey = apiKey;
  
  // Store in localStorage for persistence
  try {
    localStorage.setItem('openai_api_key', apiKey);
  } catch (error) {
    console.error('Failed to store API key in localStorage:', error);
  }
};

// Helper to get the API key from memory or localStorage
export const getOpenAIApiKey = (): string | null => {
  // If we already have it in memory, return it
  if (openaiApiKey) {
    return openaiApiKey;
  }
  
  // Try to retrieve from localStorage
  try {
    const storedKey = localStorage.getItem('openai_api_key');
    if (storedKey) {
      openaiApiKey = storedKey;
      return storedKey;
    }
  } catch (error) {
    console.error('Failed to retrieve API key from localStorage:', error);
  }
  
  return null;
};

// Method to test API key
export const testApiKey = async (): Promise<{ success: boolean; message: string }> => {
  if (!openaiApiKey) {
    return { 
      success: false, 
      message: "No API key provided. Please enter an OpenAI API key." 
    };
  }

  // Adding a delay to simulate API call
  await new Promise(resolve => setTimeout(resolve, 1000));

  // Basic validation check for SK format
  if (!openaiApiKey.startsWith('sk-') || openaiApiKey.length < 30) {
    return { 
      success: false, 
      message: "Invalid API key format. OpenAI API keys typically start with 'sk-'" 
    };
  }

  // This is just a simulation. In a real app, you would make an actual API call to OpenAI
  // to validate the key using their authentication endpoints
  return { 
    success: true, 
    message: "API key validation successful! You can now use OpenAI enhancements." 
  };
};

/**
 * Enhances chapter content using AI processing
 * 
 * @param content The original content to enhance
 * @param enhancementType The type of enhancement to apply
 * @param customPrompt Optional custom prompt to guide the enhancement
 * @returns Enhanced content
 */
export const enhanceChapterContent = async (
  content: string,
  enhancementType: string,
  customPrompt?: string
): Promise<string> => {
  // In a real app, this would call OpenAI or another service
  // For this simplified version, we'll simulate enhancement
  
  // Add some delay to simulate API call - longer for realistic processing time
  const processingTime = Math.random() * 2000 + 1000; // 1-3 seconds
  await new Promise(resolve => setTimeout(resolve, processingTime));
  
  let enhancedContent = content;
  
  // If a custom prompt is provided, we would use it to guide the enhancement
  // In a real implementation, this would be passed to the AI service
  if (customPrompt) {
    console.log(`Using custom prompt for enhancement: ${customPrompt.substring(0, 100)}...`);
    
    // Simulate more extensive processing when using a custom prompt
    await new Promise(resolve => setTimeout(resolve, 1000)); // Additional delay
    
    // For simulation, modify the content slightly differently when using a custom prompt
    enhancedContent = content
      .replace(/\b(the|a|an)\b/gi, match => match.toUpperCase())
      .replace(/\n\n/g, '</p><p>')
      .replace(/^/, '<p><em>Enhanced with custom prompt: </em>')
      .replace(/$/, '</p>');
      
    return enhancedContent;
  }
  
  // Regular enhancements as before
  switch (enhancementType) {
    case 'grammar':
      // Simulate grammar corrections
      enhancedContent = content
        .replace(/\bi\b/g, 'I')
        .replace(/\bdont\b/g, "don't")
        .replace(/\bwont\b/g, "won't")
        .replace(/\bcant\b/g, "can't")
        .replace(/\bim\b/g, "I'm")
        .replace(/\bId\b/g, "I'd")
        .replace(/\bIll\b/g, "I'll")
        .replace(/\bIve\b/g, "I've")
        .replace(/\bdidnt\b/g, "didn't")
        .replace(/\bcouldnt\b/g, "couldn't")
        .replace(/\bwouldnt\b/g, "wouldn't")
        .replace(/\bshouldnt\b/g, "shouldn't")
        .replace(/\bisnt\b/g, "isn't")
        .replace(/\barent\b/g, "aren't")
        .replace(/\bhasnt\b/g, "hasn't")
        .replace(/\bhavent\b/g, "haven't")
        .replace(/\btheres\b/g, "there's")
        .replace(/\bTheyre\b/g, "They're")
        .replace(/\btheyre\b/g, "they're")
        .replace(/\byoure\b/g, "you're")
        .replace(/([.!?:;,])([^\s\d"])/g, '$1 $2'); // Add space after punctuation
      break;
      
    case 'expand':
      // Simulate content expansion by adding a paragraph
      const paragraphs = content.split('</p>');
      if (paragraphs.length > 1) {
        // Insert expansion after the first paragraph
        const expansionText = '<p>This represents expanded content that would normally be generated by an AI model. In a real implementation, this would analyze the context and add relevant, engaging content to enrich the reading experience.</p>';
        paragraphs.splice(1, 0, expansionText);
        enhancedContent = paragraphs.join('</p>');
      }
      break;
      
    case 'clarity':
      // Simulate clarity improvements
      enhancedContent = content
        .replace(/very /g, '')
        .replace(/really /g, '')
        .replace(/basically /g, '')
        .replace(/just /g, '')
        .replace(/([.!?:;,])([^\s\d"])/g, '$1 $2') // Add space after punctuation
        .replace(/ +/g, ' '); // Remove multiple spaces
      break;
      
    case 'style':
      // Simulate professional style improvements
      enhancedContent = content
        // Improve professional terminology
        .replace(/good/g, 'excellent')
        .replace(/bad/g, 'suboptimal')
        .replace(/big/g, 'substantial')
        .replace(/small/g, 'minimal')
        // Add formatting for headings and emphasis
        .replace(/\n\s*([A-Z][^\.!?]+:)\s*\n/g, '<h3>$1</h3>')
        .replace(/\?\? ([^\.!?]+)/g, '<h3>$1</h3>')
        .replace(/\? ([^\.!?]+)/g, '<strong>$1</strong>')
        // Format examples and key points
        .replace(/Example:/g, '<strong>Example:</strong>')
        .replace(/Key (Rules|Points|Takeaways|Lessons):/g, '<strong>Key $1:</strong>')
        // Add paragraph structure where missing
        .replace(/\n\n/g, '</p><p>')
        // Clean up any formatting artifacts
        .replace(/<\/p><p><\/p><p>/g, '</p><p>')
        .replace(/^/, '<p>') // Ensure document starts with paragraph
        .replace(/$/, '</p>'); // Ensure document ends with paragraph close
      break;
  }
  
  // Add a small random element to the enhancement to simulate AI variation
  if (Math.random() > 0.7) {
    enhancedContent = enhancedContent.replace(
      /<p>/i, 
      '<p><em>Note: </em>'
    );
  }
  
  return enhancedContent;
};

/**
 * Log processing errors to help with debugging
 */
export const logEnhancementError = (error: any, context: string): void => {
  console.error(`Enhancement error (${context}):`, error);
  
  // In a real implementation, this would log to a server or analytics service
  const errorDetails = {
    timestamp: new Date().toISOString(),
    context,
    error: error.message || String(error),
    stack: error.stack,
  };
  
  // Log to console in a structured format for easier debugging
  console.error('Enhancement Error Details:', JSON.stringify(errorDetails, null, 2));
};

// Default prompt templates for book enhancement
export const getPromptTemplates = () => {
  return [
    {
      id: 'default',
      name: 'Standard Enhancement',
      description: 'Basic document enhancement focusing on grammar, clarity, and style.',
      prompt: 'Enhance this document by improving grammar, clarity, and professional style while maintaining the original meaning and content structure.'
    },
    {
      id: 'judicial',
      name: 'Judicial Writing',
      description: 'Optimized for legal and judicial documents with precise formatting and citations.',
      prompt: `Refine and enhance this document by improving readability, removing redundancies, strengthening transitions, and enhancing formatting consistency. Ensure it remains engaging, well-structured, and easy to navigate for court reporters.

Key Improvement Areas:
- Remove Redundancies: Avoid repeating case studies and streamline discussions on formatting rules.
- Enhance Readability & Structure: Break up large blocks of text with subheadings and improve section transitions.
- Standardize Formatting & Style: Ensure consistent use of formatting for examples and key terms.
- Improve Practical Applications: Add more interactive examples and checklists.
- Clarify Legal & Technical References: Ensure all legal citation styles are accurate and consistently formatted.

Write in a clear, engaging, and professional tone while maintaining proper legal formatting where applicable.`
    },
    {
      id: 'academic',
      name: 'Academic Paper',
      description: 'Formats text according to academic standards with proper citations and terminology.',
      prompt: 'Enhance this document following academic writing standards. Ensure proper citation format, academic terminology, clear argumentation, and maintain a formal scholarly tone throughout.'
    },
    {
      id: 'creative',
      name: 'Creative Writing',
      description: 'Enhances narrative flow, descriptive language, and character development.',
      prompt: 'Enhance this creative text by improving narrative flow, enriching descriptive language, developing characters more fully, and creating more engaging dialogue while preserving the original story and author\'s voice.'
    },
    {
      id: 'technical',
      name: 'Technical Documentation',
      description: 'Optimizes technical documentation with clear explanations and consistent terminology.',
      prompt: 'Enhance this technical documentation by improving clarity, ensuring consistent terminology, adding appropriate examples, and structuring content for easy reference. Maintain technical accuracy while making concepts more accessible.'
    },
    {
      id: 'book_rewrite',
      name: 'Book Rewriting',
      description: 'Complete book restructuring, refinement and enhancement for professional publication.',
      prompt: `Refine and enhance this book by improving readability, removing redundancies, strengthening transitions, and enhancing formatting consistency. Ensure it remains engaging, well-structured, and easy to navigate for readers.

Key Improvement Areas:
- Remove Redundancies: Avoid repeating case studies and examples. Instead, reference them once and link back where necessary.
- Enhance Readability & Structure: Break up large blocks of text with subheadings, bullet points, and numbered lists.
- Standardize Formatting & Style: Ensure consistent use of formatting for examples and key terms.
- Improve Practical Applications: Add more interactive elements and examples where appropriate.
- Clarify Technical References: Ensure all citations and references are accurate and consistently formatted.

Write in a clear, engaging, and professional tone while maintaining the original voice and intent of the author.`
    }
  ];
};

/**
 * Save a custom book prompt to localStorage 
 */
export const saveCustomBookPrompt = (bookTitle: string, prompt: string): void => {
  try {
    // Get existing prompts or initialize empty object
    const existingPromptsJSON = localStorage.getItem('custom_book_prompts');
    const bookPrompts = existingPromptsJSON ? JSON.parse(existingPromptsJSON) : {};
    
    // Add or update prompt for this book
    bookPrompts[bookTitle] = prompt;
    
    // Save back to localStorage
    localStorage.setItem('custom_book_prompts', JSON.stringify(bookPrompts));
    
    console.log(`Saved custom prompt for book: ${bookTitle}`);
  } catch (error) {
    console.error('Failed to save custom book prompt:', error);
  }
};

/**
 * Get custom book prompt from localStorage
 */
export const getCustomBookPrompt = (bookTitle: string): string | null => {
  try {
    const existingPromptsJSON = localStorage.getItem('custom_book_prompts');
    if (!existingPromptsJSON) return null;
    
    const bookPrompts = JSON.parse(existingPromptsJSON);
    return bookPrompts[bookTitle] || null;
  } catch (error) {
    console.error('Failed to retrieve custom book prompt:', error);
    return null;
  }
};

/**
 * Get all saved custom book prompts
 */
export const getAllCustomBookPrompts = (): Record<string, string> => {
  try {
    const existingPromptsJSON = localStorage.getItem('custom_book_prompts');
    return existingPromptsJSON ? JSON.parse(existingPromptsJSON) : {};
  } catch (error) {
    console.error('Failed to retrieve custom book prompts:', error);
    return {};
  }
};
